# 第一周学习笔记

## 学习方法

- 5分钟不会，直接看题解，理解后自己写出
- 查看其它思路
- 查看国际站最优思路
- 重复，过遍数

刻意练习，**记忆**+理解



## 刷题记录

额外刷题，来自LC日推题，群内每日一题，随性刷题等

| #    | 题目名                                                       | 难度  | 关键词                                                       | 已过遍数 | 感觉 |
| ---- | ------------------------------------------------------------ | ----- | ------------------------------------------------------------ | -------- | ---- |
| 130  | [被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/) | 💛中等 | [DFS](https://leetcode-cn.com/tag/depth-first-search/), [BFS](https://leetcode-cn.com/tag/breadth-first-search/), [并查集](https://leetcode-cn.com/tag/union-find/) | 1        |      |
| 92   | [反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) | 💛中等 | [链表](https://leetcode-cn.com/tag/linked-list/)             | 2        |      |
| 202  | [快乐数](https://leetcode-cn.com/problems/happy-number/)     | 💚简单 | [哈希表](https://leetcode-cn.com/tag/hash-table/)，[数学](https://leetcode-cn.com/tag/math/) | 1        |      |
| 287  | [寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/) | 💛中等 | [数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/)，[二分查找](https://leetcode-cn.com/tag/binary-search/) | 1        |      |
| 225  | [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/) | 💚简单 | [设计](https://leetcode-cn.com/tag/design/)                  |          |      |
| 232  | [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/) | 💚简单 | [设计](https://leetcode-cn.com/tag/design/)                  |          |      |
| 299  | [猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/) | 💚简单 | [哈希表](https://leetcode-cn.com/tag/hash-table/)            | 1        |      |

实践题

| #    | 题目名                                                       | 难度  | 关键词                                                       | 已过遍数 | 感觉 |
| ---- | ------------------------------------------------------------ | ----- | ------------------------------------------------------------ | -------- | ---- |
| 146  | [LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)   | 💛中等 | [设计](https://leetcode-cn.com/tag/design/)                  | 5        | 😆    |
| 11   | [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/) | 💛中等 | [数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 6        | 😆    |
| 70   | [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)  | 💚简单 | [DP](https://leetcode-cn.com/tag/dynamic-programming/)       | 5        | 😉    |
| 15   | [三数之和](https://leetcode-cn.com/problems/3sum/)           | 💛中等 | [数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/)，[哈希表](https://leetcode-cn.com/tag/hash-table/) | 4        | 😉    |
| 206  | [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) | 💚简单 | [链表](https://leetcode-cn.com/tag/linked-list/)             | 4        | 😆    |
| 24   | [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs) | 💛中等 | [链表](https://leetcode-cn.com/tag/linked-list/)             | 4        | 😆    |
| 141  | [环形链表](https://leetcode-cn.com/problems/linked-list-cycle) | 💛中等 | [链表](https://leetcode-cn.com/tag/linked-list/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 4        | 😆    |
| 142  | [环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii) | 💛中等 | [链表](https://leetcode-cn.com/tag/linked-list/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 4        | 😆    |
| 25   | [K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) | 🧡困难 | [链表](https://leetcode-cn.com/tag/linked-list/)             | 4        | 😆    |
| 20   | [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) | 💚简单 | [栈](https://leetcode-cn.com/tag/stack/)，[字符串](https://leetcode-cn.com/tag/string/) | 4        | 😆    |
| 155  | [最小栈](https://leetcode-cn.com/problems/min-stack/)        | 💚简单 | [栈](https://leetcode-cn.com/tag/stack/)，[设计](https://leetcode-cn.com/tag/design/) | 4        | 😆    |
| 84   | [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram) | 🧡困难 | [栈](https://leetcode-cn.com/tag/stack/)，[数组](https://leetcode-cn.com/tag/array/) | 4        | 😉    |
| 239  | [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum) | 🧡困难 | 堆，[Sliding Window](https://leetcode-cn.com/tag/sliding-window/) | 2        | 😐    |

作业题

| #    | 题目名                                                       | 难度  | 关键词                                                       | 已过遍数 | 感觉 |
| ---- | ------------------------------------------------------------ | ----- | ------------------------------------------------------------ | -------- | ---- |
| -    | 改写 Deque (用add first/last)                                | -     | 设计，队列                                                   | 见下文   | -    |
| -    | 分析 Queue 和 Priority Queue 源码                            | -     | 设计，队列                                                   | 见下文   | -    |
| 26   | [删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/) | 💚简单 | [数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 3        |      |
| 189  | [旋转数组](https://leetcode-cn.com/problems/rotate-array/)   | 💚简单 | [数组](https://leetcode-cn.com/tag/array/)                   | 2        |      |
| 21   | [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) | 💚简单 | [链表](https://leetcode-cn.com/tag/linked-list/)             | 2        |      |
| 88   | [合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) | 💚简单 | [数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 2        |      |
| 1    | [两数之和](https://leetcode-cn.com/problems/two-sum/)        | 💚简单 | [数组](https://leetcode-cn.com/tag/array/)，[哈希表](https://leetcode-cn.com/tag/hash-table/) | 4        |      |
| 283  | [移动零](https://leetcode-cn.com/problems/move-zeroes/)      | 💚简单 | [数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 4        |      |
| 66   | [加一](https://leetcode-cn.com/problems/plus-one/)           | 💚简单 | [数组](https://leetcode-cn.com/tag/array/)                   | 4        |      |
| 641  | [设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque) | 💛中等 | [设计](https://leetcode-cn.com/tag/design/)，[队列](https://leetcode-cn.com/tag/queue/) | 2        |      |
| 42   | [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) | 🧡困难 | [栈](https://leetcode-cn.com/tag/stack/)，[数组](https://leetcode-cn.com/tag/array/)，[双指针](https://leetcode-cn.com/tag/two-pointers/) | 1        |      |

*感觉列表*

| 完全掌握 | 还能更熟 | 还得练练 | 还没搞懂 | 这是什么鬼？ |
| :------: | :------: | :------: | :------: | :----------: |
|    😆     |    😉     |    😐     |    🤨🤔    |      🤪       |



## 视频笔记

### 1. 数组，链表，跳表

数组：在内存中开辟连续的内存地址，存储元素

链表：当前Node对象储存当前节点值与下一节点内存地址

跳表：带有跳表索引的链表，只能用于**元素有序**的情况下，用来取代平衡树二分查找

|          | 左append | 右append | 查询         | 插入         | 删除         |
| -------- | -------- | -------- | ------------ | ------------ | ------------ |
| 数组     | O(1)     | O(1)     | O(1)         | **O(n)**     | **O(n)**     |
| 普通链表 | O(1)     | O(1)     | **O(n)**     | O(1)         | O(1)         |
| 跳表     | O(1)     | O(1)     | **O(log n)** | **O(log n)** | **O(log n)** |

空间复杂度上，数组最少，普通链表第二，跳表最高，但，都是O(n)。

链表应用：LRU Cache

跳表应用：Redis

### 2. 栈和队列

栈（Stack）：先入后出（LIFO/FILO）

队列（Queue）：先入先出（FIFO）

|      | 左append | 右append | 查询     | 插入 | 删除 |
| ---- | -------- | -------- | -------- | ---- | ---- |
| 栈   | -        | O(1)     | **O(n)** | -    | O(1) |
| 队列 | -        | O(1)     | **O(n)** | -    | O(1) |

各数据结构复杂度对比网站：https://www.bigocheatsheet.com/

在python中，可以用heapq实现PriorityQueue，用collections.deque实现栈/队列



#### 改写Deque（Python）

简单实现deque对象，使其具有 addfirst() 和 addlast() 接口：

```python
class Deque():
    def __repr__(self):
        return str(self.list)
    
    def __init__(self):
        self.list = []
        
    def addfirst(self, num):
        self.list = [num] + self.list
    
    def addlast(self, num):
        self.list.append(num)
        
    def popleft(self):
        if not self.list: raise IndexError("pop from empty list")
        x = self.list[0]
        self.list.__delitem__(0)
        return x
    
    def popright(self):
        if not self.list: raise IndexError("pop from empty list")
        x = self.list[-1]
        self.list.__delitem__(-1)
        return x
```

也见leetcode题目：[641.设计循环双端队列](https://github.com/SimZhou/algorithm014-algorithm014/blob/master/Week_01/Homeworks/641.%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.py)

#### 分析Queue和Priority Queue源码（Python）

Python中的 [Queue](https://docs.python.org/3/library/queue.html#queue.Queue) 和 [PriorityQueue](https://docs.python.org/3/library/queue.html#queue.PriorityQueue) 都在 queue 这个模块中，以下是源码，我把部分注释翻译了一下

##### **Queue** 

位于`Miniconda3\Lib\queue.py`文件 `Line 27-217`

```python
class Queue:
    '''创建一个给定maxsize的队列.
    如果 maxsize <= 0, 队列大小是无穷大（下面可以看到默认值为0）.
    '''
    
    def __init__(self, maxsize=0):
        self.maxsize = maxsize
        self._init(maxsize)
		
        # mutex——互斥锁，属于线程锁。
        # 任何时候队列在发生改变时，必须加持有互斥锁。
        # 所有需要加锁的方法，在返回值之前必须释放锁。
        # 互斥锁在以上三种状态（|<--1-->|加锁|<--2-->|释放锁|<--3-->|）时是共享的。
        # 因此，获取或者释放状态时，也获取和释放了互斥锁
        self.mutex = threading.Lock()
		
        # 
        # Notify not_empty whenever an item is added to the queue; a
        # thread waiting to get is notified then.
        self.not_empty = threading.Condition(self.mutex)

        # Notify not_full whenever an item is removed from the queue;
        # a thread waiting to put is notified then.
        self.not_full = threading.Condition(self.mutex)

        # Notify all_tasks_done whenever the number of unfinished tasks
        # drops to zero; thread waiting to join() is notified to resume
        self.all_tasks_done = threading.Condition(self.mutex)
        self.unfinished_tasks = 0

    def task_done(self):
        '''Indicate that a formerly enqueued task is complete.
		
		
        Used by Queue consumer threads.  For each get() used to fetch a task,
        a subsequent call to task_done() tells the queue that the processing
        on the task is complete.

        If a join() is currently blocking, it will resume when all items
        have been processed (meaning that a task_done() call was received
        for every item that had been put() into the queue).

        Raises a ValueError if called more times than there were items
        placed in the queue.
        '''
        with self.all_tasks_done:
            unfinished = self.unfinished_tasks - 1
            if unfinished <= 0:
                if unfinished < 0:
                    raise ValueError('task_done() called too many times')
                self.all_tasks_done.notify_all()
            self.unfinished_tasks = unfinished

    def join(self):
        '''阻塞，直到Queue中的所有对象都被获取并处理了。
        Blocks until all items in the Queue have been gotten and processed.
		
		任何时候一个对象被加进Queue中后，未完成任务的计数都会增加。
		任何时候一个消费者线程调用task_done()方法表明一个对象被获取且工作完毕了，这个计数都会减少。
        The count of unfinished tasks goes up whenever an item is added to the
        queue. The count goes down whenever a consumer thread calls task_done()
        to indicate the item was retrieved and all work on it is complete.
		
		当未完成任务的计数减少到0时，join()方法的阻塞被释放。
        When the count of unfinished tasks drops to zero, join() unblocks.
        '''
        with self.all_tasks_done:
            while self.unfinished_tasks:
                self.all_tasks_done.wait()

    def qsize(self):
        '''返回队列的大概长度 (不可靠!).'''
        with self.mutex:
            return self._qsize()

    def empty(self):
        '''判断一个队列是否为空，是返回True，否返回False (不可靠!).
		
		这个方法可能会在未来被删除。直接使用qsize()方法来判断队列是否为空。
        This method is likely to be removed at some point.  Use qsize() == 0
        as a direct substitute, but be aware that either approach risks a race
        condition where a queue can grow before the result of empty() or
        qsize() can be used.

        To create code that needs to wait for all queued tasks to be
        completed, the preferred technique is to use the join() method.
        '''
        with self.mutex:
            return not self._qsize()

    def full(self):
        '''Return True if the queue is full, False otherwise (not reliable!).

        This method is likely to be removed at some point.  Use qsize() >= n
        as a direct substitute, but be aware that either approach risks a race
        condition where a queue can shrink before the result of full() or
        qsize() can be used.
        '''
        with self.mutex:
            return 0 < self.maxsize <= self._qsize()

    def put(self, item, block=True, timeout=None):
        '''Put an item into the queue.
		把一个对象放进队列。
		
		如果可选参数 block 为True, 并且 timeout 为 None，那么操作会阻塞，直到队列有可用空间。
		如果 timeout 为非负整数，则会阻塞指定时间，如果这段时间都没有位置释放，则会报错。
		
		其他情况（block为false），队列如果有空槽位则直接放进去，没有则直接报错。
		
        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until a free slot is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Full exception if no free slot was available within that time.
        Otherwise ('block' is false), put an item on the queue if a free slot
        is immediately available, else raise the Full exception ('timeout'
        is ignored in that case).
        '''
        with self.not_full:
            if self.maxsize > 0:
                if not block:
                    if self._qsize() >= self.maxsize:
                        raise Full
                elif timeout is None:
                    while self._qsize() >= self.maxsize:
                        self.not_full.wait()
                elif timeout < 0:
                    raise ValueError("'timeout' must be a non-negative number")
                else:
                    endtime = time() + timeout
                    while self._qsize() >= self.maxsize:
                        remaining = endtime - time()
                        if remaining <= 0.0:
                            raise Full
                        self.not_full.wait(remaining)
            self._put(item)
            self.unfinished_tasks += 1
            self.not_empty.notify()

    def get(self, block=True, timeout=None):
        '''Remove and return an item from the queue.

        If optional args 'block' is true and 'timeout' is None (the default),
        block if necessary until an item is available. If 'timeout' is
        a non-negative number, it blocks at most 'timeout' seconds and raises
        the Empty exception if no item was available within that time.
        Otherwise ('block' is false), return an item if one is immediately
        available, else raise the Empty exception ('timeout' is ignored
        in that case).
        '''
        with self.not_empty:
            if not block:
                if not self._qsize():
                    raise Empty
            elif timeout is None:
                while not self._qsize():
                    self.not_empty.wait()
            elif timeout < 0:
                raise ValueError("'timeout' must be a non-negative number")
            else:
                endtime = time() + timeout
                while not self._qsize():
                    remaining = endtime - time()
                    if remaining <= 0.0:
                        raise Empty
                    self.not_empty.wait(remaining)
            item = self._get()
            self.not_full.notify()
            return item

    def put_nowait(self, item):
        '''Put an item into the queue without blocking.

        Only enqueue the item if a free slot is immediately available.
        Otherwise raise the Full exception.
        '''
        return self.put(item, block=False)

    def get_nowait(self):
        '''Remove and return an item from the queue without blocking.

        Only get an item if one is immediately available. Otherwise
        raise the Empty exception.
        '''
        return self.get(block=False)

    # Override these methods to implement other queue organizations
    # (e.g. stack or priority queue).
    # These will only be called with appropriate locks held

    # 实例化类时调用的函数，可以看到，Queue实际上是一个deque()对象
    # Initialize the queue representation
    def _init(self, maxsize):
        self.queue = deque()

    # 返回队列的长度
    def _qsize(self):
        return len(self.queue)

    # 在队列中添加(append)一个新对象
    def _put(self, item):
        self.queue.append(item)

    # 从队列中获取(popleft)一个对象
    def _get(self):
        return self.queue.popleft()
```

可以看到核心的 put() 和 get() 两个方法，其实用的就是 append 和 popleft 来实现的，为什么有 popleft 方法？这其实是因为 **Queue 其实是一个 deque 对象** （在_init()方法中定义了）。

##### **deque**

继续深挖，找不到 deque 的 .py 源码，于是发现 python 的 collections 库其实是用c语言（cpython）实现的，在这里：[_collectionsmodule.c](https://github.com/python/cpython/blob/master/Modules/_collectionsmodule.c) 。源码太长，看不懂太c，就不继续深挖了。由于deque是c语言的实现，所以我们有理由相信deque具有非常不错的性能，以后可以多多使用。

##### **PriorityQueue**

位于`Miniconda3\Lib\queue.py`文件 `Line 220-236`

```python
class PriorityQueue(Queue):
    '''Variant of Queue that retrieves open entries in priority order (lowest first).

    Entries are typically tuples of the form:  (priority number, data).
    '''

    def _init(self, maxsize):
        self.queue = []

    def _qsize(self):
        return len(self.queue)

    def _put(self, item):
        heappush(self.queue, item)

    def _get(self):
        return heappop(self.queue)
```

可以看到PriorityQueue本身其实就是一个Queue的类继承，它改写了Queue的 \_put() 和 \_get() 方法，使用了 heappush 和 heappop 方法替代了原来的 append 和 pop，在插入和获取对象的同时，会对 Queue 实例中的元素进行排序。查阅 heapq 库，可以看到这两个方法：

```python
def heappush(heap, item):
    """Push item onto heap, maintaining the heap invariant."""
    heap.append(item)
    _siftdown(heap, 0, len(heap)-1)

def heappop(heap):
    """Pop the smallest item off the heap, maintaining the heap invariant."""
    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftup(heap, 0)
        return returnitem
    return lastelt
```

这两个方法基本上就是堆的特有方法，可以看到 python 的 **heap 其实就是 python 基本的 list 对象**，使用pop，append等方法来操作。

##### heapq

进一步看以下 heapq（[文档](https://docs.python.org/3.8/library/heapq.html)） 这个库，这个库提供了有如下方法：

```python
__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace', 'merge',
           'nlargest', 'nsmallest', 'heappushpop']
```

最常用的应该是 `heappush` 和 `heappop` 这两个。还有`heapify`（将传入对象转化为满足堆的顺序）

例如：`heapify`

```python
>>> l = [6,3,5,2,1,8,7]
>>> heapq.heapify(l)
>>> l
[1, 2, 5, 6, 3, 8, 7]
```

`heappush`提供插入一个元素到堆中的功能：

```python
>>> heapq.heappush(l, 4)
>>> l
[1, 2, 5, 4, 3, 8, 7, 6]
```

`heappop`提供从堆中获取一个元素的功能，且获取的元素为堆中最小值

```python
>>> heapq.heappop(l)
1
>>> heapq.heappop(l)
2
>>> heapq.heappop(l)
3
>>> heapq.heappop(l)
4
>>> heapq.heappop(l)
5
>>> heapq.heappop(l)
6
>>> heapq.heappop(l)
7
>>> heapq.heappop(l)
8
```

`nlargest`提供查询堆中最大n个元素的功能

```python
>>> heapq.nlargest(4, l)
[8, 7, 6, 5]
# 下面两个是乱打的列表，不满足堆结构，但依旧能查询，推测会先自动heapify
>>> heapq.nlargest(4, [1,3,6,3,8,2,2,3,6,9])
[9, 8, 6, 6]
>>> heapq.nlargest(4, [19,3,6,3,8,2,2,3,6,9])
[19, 9, 8, 6]
# 支持key功能
>>> heapq.nlargest(4, [(1,"D"),(2,"C")], key=lambda x: x[1])
[(1, 'D'), (2, 'C')]
```

`heapreplace`，pop一个，然后push一个。

官方还提供了一个用heapq库进行堆排序的例子：

```python
>>> def heapsort(iterable):
...     h = []
...     for value in iterable:
...         heappush(h, value)
...     return [heappop(h) for i in range(len(h))]
...
>>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

另外，heapq这个库仅仅实现了最小堆，而没有最大堆这个功能，如果要用heapq做最大堆，有一个trick，就是用负数来存元素：

```python
# Python3 program to demonstrate working of heapq 

from heapq import heappop, heappush, heapify 
  
# Creating empty heap 
heap = [] 
heapify(heap) 
  
# Adding items to the heap using heappush 
# function by multiplying them with -1 
heappush(heap, -1 * 10) 
heappush(heap, -1 * 30) 
heappush(heap, -1 * 20) 
heappush(heap, -1 * 400) 
  
# printing the value of maximum element 
print("Head value of heap : "+str(-1 * heap[0])) 
  
# printing the elements of the heap 
print("The heap elements : ") 
for i in heap: 
    print(-1 * i, end = ' ') 
print("\n") 
  
element = heappop(heap) 
  
# printing the elements of the heap 
print("The heap elements : ") 
for i in heap: 
    print(-1 * i, end = ' ') 
```

