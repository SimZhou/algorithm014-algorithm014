# 参考https://blog.csdn.net/happyrocking/article/details/83619392
# 字典序算法用来解决这样一个问题：
# 给定其中一种排列，求基于字典序的下一种排列。
# 比如给定一种排列为 abc，则其基于字典序的下一种排列为 acb。
# 
# 以输入为 358764 为例，字典序算法的步骤：
#   1、从原排列中，从右至左，找到第一个左邻小于本身的左邻，记左邻位置为 a。
#       示例中 a=1，list[a] = 5。
#   2、重新从右至左，找到第一个比 list[a] 大的字符，记为位置为 b。
#       示例中 b=4，list[b] = 6。
#   3、交换 a 和 b 两个位置的值。
#       示例变为了 368754。
#   4、将 a 后面的数，由小到大排列。
#       示例变为了 364578。
# 算法结束，输出 364578。
# 注意：
#   1、第1步中，如果找不到左邻小于右邻的数，则说明给定的排列已经是全排列的最后一个排列了，则直接返回全排列的第一个排列，即所有排列中最小的排列，形成一个循环。
#   2、在第3步交换前，a 后面的数是按照从大到小进行排列（否则第1步中就可以找到左邻小于右邻的数了）。
#   3、在交换之后，a 后面的数仍然是按照从大到小排列的，尽管 b 位置的值变成了 list[a]，但是由于 b 位置是第一个比 list[a] 大的，因此交换之后 list[a] 仍然比左邻小，比右邻大。
#   4、既然 a 后面的数是从大到小排列的，那么第4步的排序，直接将 a 后面的数倒序即可。
# 算法的时间复杂度为 O(n) + O(n) + O(n) = O(n)。

def nextPermutation(s):
    '''[1,2,3]'''
    for i in range(len(s)-2, -1, -1):
        if s[i] < s[i+1]: 
            break
    else:
        s[:] = s[::-1]
        print(s)
        return
    for j in range(len(s)-1, -1, -1):
        if s[i] < s[j]: 
            break
    s[i], s[j] = s[j], s[i]
    s[i+1:] = s[-1:i:-1]
    print(s)
    
if __name__ == "__main__":
    a = [3,2,1]
    for i in range(10):
        nextPermutation(a)
    
    